# l1 = [11, 45, 23, 81, 28, 34]
# l2 = [11, 45, 22, 81, 23, 34, 99, 22, 17, 8]
# l3 = [1, 1, 1, 1, 1, 0, 0, 0, 0, 0]


def partition(A, l, r):
    # 피봇 정하기(제일 왼쪽 부분)
    p = A[l]

    # 피봇보다 작은거는 왼쪽부터 놓고, 큰거는 오른쪽부터 놓고
    i, j = l, r
    # i : 왼쪽에 있으면 안되는 원소의 위치를 찾는 인덱스
    # 피봇보다 큰 원소의 위치 왼쪽부터 찾기

    # j : 오른쪽에 있으면 안되는 원소의 위치를 찾는 인덱스
    # 피봇보다 작은 원소의 위치 오른쪽부터 찾기
    while i <= j:
        # 피봇보다 큰거를 왼쪽부터 찾기 시작
        while i <= j and A[i] <= p:
            # i번째 위치에 있는 원소가 피봇보다 작으면 오른쪽으로 한칸 가서 찾기 계속
            i += 1
        # 피봇보다 작은거를 오른쪽부터 찾기 시작
        while i <= j and A[j] >= p:
            # j번째 위치에 있는 원소가 피봇보다 크면 왼쪽으로 한칸 가서 찾기 계속
            j -= 1

        # i가 j보다 작으면 위치가 잘못된 두 원소를 찾음
        if i < j:
            # 잘못된 원소끼리 자리 교환
            A[i], A[j] = A[j], A[i]

    # 반복이 끝나면 작은것과 큰것이 다 제자리에 있다.
    # 피봇의 위치를 정해준다
    A[l], A[j] = A[j], A[l]

    # 정렬이 끝난 피벗의 위치
    return j


# A: 정렬할 대상 리스트
# l : 왼쪽 인덱스
# r : 오른쪽 인덱스
def quickSort(A, l, r):
    if l < r:
        # 분할하고 피봇의 위치를 구한다.
        s = partition(A, l, r)
        # s의 위치는 정해지고 s의 나머지 부분에 대해서 분할정렬 이어가기

        # s를 제외한 왼쪽 부분 정렬
        quickSort(A, l, s - 1)
        # s를 제외한 오른쪽 부분 정렬
        quickSort(A, s + 1, r)


l1 = [11, 45, 23, 81, 28, 34]
l2 = [11, 45, 22, 81, 23, 34, 99, 22, 17, 8]
l3 = [1, 1, 1, 1, 1, 0, 0, 0, 0, 0]

N = len(l1)
quickSort(l1, 0, N - 1)
print(l1)
