arr = [3, 6, 7, 1, 5, 4]

n = len(arr)  # n : 집합의 원소의 개수

# arr 의 부분집합의 개수 2^6 == 1 << 6 == 1 * 2^6
# 3 << 4 == 3 * 2^4

# 모든 부분집합을 검사
for i in range(1 << n):  # 부분집합의 개수만큼 반복 / 1 << n = 2**n
    # i번째 부분집합을 검사
    # i번째 부분집합이 n개의 원소중에 j번째 원소를 포함하는지
    for j in range(n):  # 원소의 개수가 n => n번 검사
        if i & (1 << j):  # 부분집합 i가 j번째 원소를 포함 했는지 검사
            print(arr[j], end=", ")  # j번 원소 출력
    print()
print()

# 컴퓨터는 모든 숫자를 비트로 인식한다.
# n = 6 / 1 << n : 컴퓨터가 인식하는 비트(2진수) 내에 1이 6칸 이동하기 때문에 64가 된다.
# i = 0 ~ 63 / i & (1 << j)
# i가 0 ~ 63 까지 도는데 컴퓨터는 사실 6칸의 비트(2진수)로 인식하고 있다.
# 6칸의 비트(2진수) 0 ~ 63(i) 를 돌면서 1을 j 번 만큼 밀었을 때 i와 j가 같으면 출력
# 결론적으로 arr의 길이만큼의 비트(2진수)를 구성하고
# 비트 안에서 0 ~ 63 까지 2진수로 돌면서
# 그 값이 1을 j번 미는 것과 같으면(부분집합에 포함) 출력

# i = 0 공집합 / i = 1(10진수) = 1(2진수) = 3(arr) / i = 2(10진수) = 10(2진수) = 6(arr)
# i = 3(10진수) = 11(2진수) = 3, 6(arr) / i = 4(10진수) = 100(2진수) = 7(arr)
# i = 5(10진수) = 101(2진수) = 3, 7(arr) / i = 6(10진수) = 110(2진수) = 6, 7(arr) ......

"""
3
19 6 16 19 15 16 8 13 16 10
-20 -6 -13 3 -19 -9 19 -3 9 4
7 7 19 1 -18 5 -9 -11 19 18
"""
